-- # 집계함수
-- 그룹특화가 아니기 때문에 쓰고 싶을 때 쓰면 된다.

SELECT SUM(QTY) AS SUM_QTY,
        MAX(YEARWEEK) AS MAX_YEARWEEK,
        MIN(YEARWEEK) AS MIN_YEARWEKK,
        COUNT(QTY) AS QTY_COUNT
FROM KOPO_CHANNEL_SEASONALITY_NEW;

-- RECORD COUNT
-- COUNT 함수는 통상적으로 아래와 같이 사용된다
SELECT COUNT(*)
FROM KOPO_CHANNEL_SEASONALITY_NEW;

SELECT COUNT(*)
FROM (SELECT *
      FROM KOPO_CHANNEL_SEASONALITY_NEW);

-- # GROUP BY
-- GROUP BY KEY를 사용하는 경우, 항상 그 키가 OUTPUT으로 나온다는 것을 유념

-- 기본 형태
SELECT REGIONID, SUM(QTY) AS SUM_QTY -- GROUP BY KEY가 SELECT 맨 앞에 나와야 한다.
FROM KOPO_CHANNEL_SEASONALITY_NEW
GROUP BY REGIONID;

-- 에러 ) GROUP BY KEY가 SELECT에 나오지 않았기 때문에
-- ORA-00979: GROUP BY 표현식이 아닙니다.
SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW
GROUP BY REGIONID;

-- 지역별 집계를 확인하고 싶은 경우
-- GROUP BY에 REGIONID
-- SELECT에 REGIONID
SELECT REGIONID,
       SUM(QTY) AS SUM_QTY,
       MAX(QTY) AS MAX_QTY,
       MIN(QTY) AS MIN_QTY,
       AVG(QTY) AS AVG_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW
GROUP BY REGIONID
ORDER BY SUM(QTY) DESC; 

-- GROUP BY KEY가 여러 개라면
-- 항상 그 키가 아웃풋으로 나온다는 점을 유념해야한다.
SELECT REGIONID, PRODUCT, 
       SUM(QTY) AS SUM_QTY,
       MAX(QTY) AS MAX_QTY,
       MIN(QTY) AS MIN_QTY,
       AVG(QTY) AS AVG_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW
GROUP BY REGIONID, PRODUCT
ORDER BY SUM(QTY) DESC;

-- 거래처별로 거래량을 확인하고 싶은 경우
SELECT ACCOUNTNAME, COUNT(*) AS COUNT
FROM KOPO_CHANNEL_RESULT
GROUP BY ACCOUNTNAME;

-- 에러 ) GROUP BY에서 WHERE 조건 사용 X, HAVING절 사용해야 한다. 
-- ORA-00933: SQL 명령어가 올바르게 종료되지 않았습니다
SELECT ACCOUNTNAME, COUNT(*)
FROM KOPO_CHANNEL_RESULT
GROUP BY ACCOUNTNAME
WHERE 1=1
AND ACCOUNT_COUNT > 10000;

-- # HAVING
-- HAVING : GROUP BY 다음에 오는 조건이 된다.
-- 집계함수에 대한 조건을 사용할 수 있다.
-- 집계함수 뒤에는 HAVING을 사용할 수 있다.
SELECT ACCOUNTNAME, COUNT(*) AS COUNT
FROM KOPO_CHANNEL_RESULT
GROUP BY ACCOUNTNAME
HAVING COUNT(QTY) > 10000;

-- # WHERE 다음에 GROUP BY
-- 조회하고 싶은 법인을 체크 후 거래처 별 실적 조회 버튼을 누르듯이
-- GROUP BY 하기 전에 WHERE 사용해서 데이터가 적게 만들면 성능이 좋아진다.
-- 조회하고 싶은 A01, A02, A03, A04를 먼저 정하고 그룹별로 집계
SELECT ACCOUNTNAME, COUNT(QTY) AS ACCOUNT_COUNT
FROM KOPO_CHANNEL_RESULT
WHERE AP2ID IN ('A01', 'A02', 'A03', 'A04')
GROUP BY ACCOUNTNAME
HAVING COUNT(QTY) > 10000;

-- HAVING절 사용하지 않고,
-- 서브쿼리에 넣어서 조회한 것에 WHERE 써서 조회하는 것도 가능하다
SELECT *
FROM
(
    SELECT ACCOUNTNAME, COUNT(QTY) AS ACCOUNT_COUNT
    FROM KOPO_CHANNEL_RESULT
    WHERE AP2ID IN ('A01', 'A02', 'A03', 'A04')
    GROUP BY ACCOUNTNAME
)
WHERE ACCOUNT_COUNT > 10000;

-- cf) CTRL + E
-- EXPLAIN PLAN
-- COST 값이 나온다
-- COST가 낮으면 낮을수록 좋다
-- COST가 크면 CPU 자원도 많이 쓴다

-- # 서브쿼리
-- cf) JOIN이 서브쿼리보다 성능이 좋다
-- 1. FROM절의 서브쿼리
-- 2. WHERE절의 서브쿼리
-- 3. SELECT절의 서브쿼리

-- 1. FROM절의 서브쿼리

SELECT *
FROM 
(
    SELECT ACCOUNTNAME,COUNT(QTY) AS ACCOUNT_COUNT
    FROM KOPO_CHANNEL_RESULT
    WHERE AP2ID IN ('A01', 'A02', 'A03', 'A04')
    GROUP BY ACCOUNTNAME
)
WHERE ACCOUNT_COUNT > 10000;


-- 기존에 없었던 새로운 컬럼을 만들었는데
-- 그 컬럼을 활용해서 활용하고 싶다면
-- 서브 쿼리를 활용해야 한다.
SELECT *
FROM 
(
    SELECT ACCOUNTNAME,
            'KOPO_'||ACCOUNTNAME AS NEW_ACCOUNT,
            COUNT(QTY) AS ACCOUNT_COUNT
    FROM KOPO_CHANNEL_RESULT
    WHERE AP2ID IN ('A01', 'A02', 'A03', 'A04')
    GROUP BY ACCOUNTNAME
)
WHERE NEW_ACCOUNT LIKE 'KOPO_A%';

-- 2. WHERE절에 서브쿼리
-- 테이블 == 서브쿼리
SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW
WHERE 1=1
AND REGIONID IN ('A01', 'A02');

SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW
WHERE 1=1
--AND REGIONID IN ('A01', '1')
AND REGIONID IN (SELECT DISTINCT REGIONID -- DISTINCT를 미리 걸면 좋다
                 FROM KOPO_PRODUCT_VOLUME);
                 
-- 위와 같은 부분에서 DISTINCT를 거는 이유는
SELECT COUNT(*)
FROM KOPO_PRODUCT_VOLUME;
-- 현재는 831건밖에 되지 않지만
-- 더 많은 데이터가 있다면 소모적일 수 있다.

-- 서브쿼리 사용시에 expression 활용 가능
-- 복합해서 사용하는 것도 가능하다
-- A01, A44가 있는데 prefix가 붙은 상태라면
-- 아래와 같이 expression 사용해서 조회할 수 있다는 점을 유의해야 한다.
SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW
WHERE 1=1
--AND REGIONID IN ('KOPO_A01', 'KOPO_A41')
AND 'KOPO_'||REGIONID IN (SELECT REGIONID 
                          FROM REGION_MST_HK);
                                        
SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW
WHERE 1=1
--AND REGIONID IN ('KOPO_A01', 'KOPO_A41')
AND LPAD(REGIONID, 8, 'KOPO_') IN (SELECT REGIONID -- DISTINCT를 미리 걸면 좋다
                                   FROM REGION_MST_HK);
                                   
-- join 시 활용
-- ON LPAD(A.REGIONID, 8, 'KOPO_') = B.REGIONID

-- 3. SELECT 절 서브쿼리
-- 주의) 단일 값을 리턴해야 한다.

-- 아래와 같은 테이블에서 컬럼을 하나 더 만들어서
SELECT A.REGIONID,
       A.PRODUCT,
       A.YEARWEEK,
       A.QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW A;
-- 특정 지역의, 특정 제품의 평균 거래량을 구하고 싶다
-- REGIONID와 PRODUCT가 같을 때 그 제품의 평균 거래량 

-- 방법 1. SELECT 절 서브쿼리
SELECT A.REGIONID,
       A.PRODUCT,
       A.YEARWEEK,
       A.QTY,
       (SELECT AVG(B.QTY)
        FROM KOPO_CHANNEL_SEASONALITY_NEW B
        WHERE 1=1
        AND B.REGIONID = A.REGIONID
        AND B.PRODUCT = A.PRODUCT
        ) AS AVG_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW A;

-- 서브쿼리 빼낸 것
-- AVG_QTY에는 44.8461538461538
SELECT AVG(B.QTY) AS AVG_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW B
WHERE 1=1
AND B.REGIONID = 'A60'
AND B.PRODUCT = 'PRODUCT4';

-- 4.8461538461538라는 값을 SELECT해서 평균을 넣을 것. 
-- REGIONID와 PRODUCT가 같은 경우에 특정 값이 필요한 것이다.
-- (우리가 필요한 건 특정 지역의, 특정 제품의 평균 거래량)
-- WHERE 조건을 쓰지 않으면 전부 다 같은 값이 나오게 된다.
-- 지역과 제품에 상관 없이 전체 데이터의 평균값이 나온다. (8949.96149246667)
-- 전체 테이블을 B라고 두고 B 테이블에 A의 REGIONID를 끌고와야 한다.

-- 방법2. join 사용

-- STEP1. 지역, 상품별 평균 판매량을 구한다
SELECT REGIONID,
       PRODUCT,
       AVG(QTY) AS AVG_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW
GROUP BY REGIONID, PRODUCT;

-- STEP2. 기존 실적데이터와 조인키 (지역, 상품) 키로 데이터를 조인한다.
SELECT *
FROM KOPO_CHANNEL_SEASONALITY_NEW A
LEFT JOIN ( 
            SELECT REGIONID,
                   PRODUCT,
                   AVG(QTY) AS AVG_QTY
            FROM KOPO_CHANNEL_SEASONALITY_NEW
            GROUP BY REGIONID, PRODUCT
           ) B
ON A.REGIONID = B.REGIONID
AND A.PRODUCT = B.PRODUCT;

-- STEP3. 정리
SELECT A.REGIONID, A.PRODUCT, A.YEARWEEK, A.QTY, B.AVG_QTY
FROM KOPO_CHANNEL_SEASONALITY_NEW A
LEFT JOIN ( 
            SELECT REGIONID,
                   PRODUCT,
                   AVG(QTY) AS AVG_QTY
            FROM KOPO_CHANNEL_SEASONALITY_NEW
            GROUP BY REGIONID, PRODUCT
           ) B
ON A.REGIONID = B.REGIONID
AND A.PRODUCT = B.PRODUCT;

-- 4. WITH 서브쿼리
-- 메모리 기반으로 쿼리를 수행한다
-- 디스크 기반으로 쿼리를 수행하면 느릴 수밖에 없다.

WITH A AS
( 
SELECT * FROM KOPO_CHANNEL_RESULT
)
SELECT * FROM A;

SELECT *
FROM ( SELECT *
       FROM KOPO_CHANNEL_RESULT
       WHERE 1=1
       AND AP2ID IN ('A01','A02')
);

-- # 조인
--  활용 추천 테이블 (KOPO_CHANNEL_RESULT, KOPO_CHANNEL_SEASONALITY_NEW)
-- 조인할 때는 개수를 유의해야 한다. (오설정으로 데이터량이 증폭될 수 있다)

-- RECORD COUNT
-- 124646
SELECT COUNT(*)
FROM KOPO_CHANNEL_SEASONALITY_NEW;

-- LEFT JOIN
-- 기준 데이터는 다 살려야 하기 때문에 기준이 되는 데이터의 개수가 동일해야 한다.
SELECT A.*, B.*
FROM KOPO_CHANNEL_SEASONALITY_NEW A
LEFT JOIN KOPO_REGION_MST B
ON A.REGIONID = B.REGIONID;

-- LEFT JOIN
-- 124646
SELECT COUNT(*)
FROM (SELECT A.*, B.*
      FROM KOPO_CHANNEL_SEASONALITY_NEW A
      LEFT JOIN KOPO_REGION_MST B
      ON A.REGIONID = B.REGIONID);


-- KOPO_CHANNEL_SEASONALITY_NEW에는 A77 법인이 있지만,
-- KOPO_REGION_MST에는 A77 법인이 없다.
-- KOPO_REGION_MST의 REGIONID에서 포함되지 않은 
-- KOPO_CHANNEL_SEASONALITY_NEW의 REGIOND를 조회한 쿼리이다.
-- 암기
SELECT DISTINCT A.REGIONID
FROM KOPO_CHANNEL_SEASONALITY_NEW A
WHERE 1=1
AND A.REGIONID NOT IN (SELECT REGIONID
                      FROM KOPO_REGION_MST);

-- INNER JOIN
-- 교집합에 해당하는 데이터만 조회된다.
SELECT A.*, B.*
FROM KOPO_CHANNEL_SEASONALITY_NEW A
INNER JOIN KOPO_REGION_MST B
ON A.REGIONID = B.REGIONID;

-- INNER JOIN
-- 124332
SELECT COUNT(*)
FROM (SELECT A.*, B.*
      FROM KOPO_CHANNEL_SEASONALITY_NEW A
      INNER JOIN KOPO_REGION_MST B
      ON A.REGIONID = B.REGIONID);

-- 원 데이터와 314라는 차이가 있다.
-- KOPO_CHANNEL_SEASONALITY_NEW에는 A77 법인이 있지만,
-- KOPO_REGION_MST에는 A77 법인이 없기 때문이다. 
-- KOPO_REGION_MST의 REGIONID에서 포함되지 않은 
-- KOPO_CHANNEL_SEASONALITY_NEW의 REGIOND를 조회한 쿼리이다.
-- 암기
SELECT DISTINCT A.REGIONID
FROM KOPO_CHANNEL_SEASONALITY_NEW A
WHERE 1=1
AND A.REGIONID NOT IN (SELECT REGIONID
                      FROM KOPO_REGION_MST);

-- A77 법인의 데이터 수
-- 314
SELECT COUNT(*)                     
FROM (SELECT A.REGIONID
        FROM KOPO_CHANNEL_SEASONALITY_NEW A
        WHERE 1=1
        AND A.REGIONID NOT IN (SELECT REGIONID
                                FROM KOPO_REGION_MST));

-- 0
SELECT COUNT(*)
FROM (SELECT A.*, B.*
      FROM KOPO_CHANNEL_SEASONALITY_NEW A -- A77 법인이 있다
      INNER JOIN KOPO_REGION_MST B -- A77 법인이 없다
      ON A.REGIONID = B.REGIONID
      WHERE 1=1
      AND A.REGIONID = 'A77');
      
      
      
-- RIGHT JOIN
-- 오른쪽 데이터(붙이는 데이터)를 살리는 것
SELECT A.*, B.*
FROM KOPO_CHANNEL_SEASONALITY_NEW A
RIGHT JOIN KOPO_REGION_MST B
ON A.REGIONID = B.REGIONID;

-- RIGHT JOIN
-- 124337 
SELECT COUNT(*)
FROM (SELECT A.*, B.*
      FROM KOPO_CHANNEL_SEASONALITY_NEW A
      RIGHT JOIN KOPO_REGION_MST B
      ON A.REGIONID = B.REGIONID);
 
-- KOPO_CHANNEL_SEASONALITY_NEW 가 가지고 있지 않은 REGIONID를 찾기   
SELECT DISTINCT REGIONID
FROM KOPO_CHANNEL_SEASONALITY_NEW;

-- KOPO_REGION_MST가 추가적으로 가지고 있는 REGIONID들을 볼 수 있다.
-- A30, A99, A49, A71, A931
SELECT A.REGIONID
FROM KOPO_REGION_MST A
WHERE 1=1
AND A.REGIONID NOT IN ( SELECT DISTINCT REGIONID
                        FROM KOPO_CHANNEL_SEASONALITY_NEW);

-- RIGHT 데이터만 가지고 있는
-- A30, A99, A49, A71, A931 법인의 데이터 수
SELECT COUNT(*)
FROM (SELECT A.REGIONID
      FROM KOPO_REGION_MST A
      WHERE 1=1
      AND A.REGIONID NOT IN ( SELECT REGIONID
                              FROM KOPO_CHANNEL_SEASONALITY_NEW));

-- 0
SELECT COUNT(*)
FROM (SELECT A.*, B.*
      FROM KOPO_CHANNEL_SEASONALITY_NEW A -- A77 법인이 있다
      INNER JOIN KOPO_REGION_MST B -- A77 법인이 없다
      ON A.REGIONID = B.REGIONID
      WHERE 1=1
      AND A.REGIONID = 'A30');                               
                                   
-- FULL OUTER JOIN
-- 124651
-- 왼쪽에도, 오른쪽에도 있는 모든 값들을 포함시켜서 출력한다.

SELECT A.*, B.*
FROM KOPO_CHANNEL_SEASONALITY_NEW A
FULL OUTER JOIN KOPO_REGION_MST B
ON A.REGIONID = B.REGIONID;

SELECT COUNT(*)
FROM (SELECT A.*, B.*
      FROM KOPO_CHANNEL_SEASONALITY_NEW A
      FULL OUTER JOIN KOPO_REGION_MST B
      ON A.REGIONID = B.REGIONID);


-- 124646
--INNER 124332
--LEFT 124646
--RIGHT 124337
--FULL OUTER JOIN 124651 

-- 테이블 네 개를 가지고 조인
SELECT C.*
FROM(
      SELECT A.*, B.REGIONNAME
      FROM KOPO_CHANNEL_SEASONALITY_NEW A -- A77 법인이 있다
      LEFT JOIN KOPO_REGION_MST B -- A77 법인이 없다
      ON A.REGIONID = B.REGIONID
      WHERE 1=1
) C
INNER JOIN KOPO_REGION_MST D
ON C.REGIONID = D.REGIONID;

--124332
SELECT COUNT(*)
FROM (SELECT C.*
      FROM(
            SELECT A.*, B.REGIONNAME
            FROM KOPO_CHANNEL_SEASONALITY_NEW A -- A77 법인이 있다
            LEFT JOIN KOPO_REGION_MST B -- A77 법인이 없다
            ON A.REGIONID = B.REGIONID
            WHERE 1=1
            ) C     
       INNER JOIN KOPO_REGION_MST D
       ON C.REGIONID = D.REGIONID);









