-- SELECTION REVIEW

SELECT *
FROM KOPO_PRODUCT_VOLUME;

SELECT REGIONID,        -- 지역아이디
       PRODUCTGROUP,    -- 상품군
       YEARWEEK         -- 연주차정보
FROM KOPO_PRODUCT_VOLUME
WHERE 1=1               -- 용이성을 위한 TRUE 조건
AND PRODUCTGROUP = 'ST0002'
AND YEARWEEK = '201502';

SELECT *
FROM KOPO_PRODUCT_VOLUME
WHERE 1=1
AND YEARWEEK > 201514
AND YEARWEEK < 201517;

SELECT *
FROM KOPO_PRODUCT_VOLUME
WHERE 1=1
OR YEARWEEK = 201514    -- OR는 쿼리에서 거의 사용하지 않는다.
OR YEARWEEK = 201516 ;

SELECT 5*30 AS MULTI
FROM DUAL;              -- DUAL은 TEST할 수 있는 TABLE

SELECT ROUND(1.876543, 2) AS MULTI
FROM DUAL;              -- 둘째 자리에서 반올림한 값을 RETURN

SELECT POWER(5, 3) AS POW
FROM DUAL;

SELECT 'SMART' || '_' || 'TECH' AS EXPR
FROM DUAL;              -- ||로 문자열 합치기 (통용)

SELECT CONCAT('11', '22') AS EXPR
FROM DUAL;              -- CONCAT으로 문자열 합치기

SELECT A.*,
      (A.VOLUME * 0.7) AS CALIB_VOLUME
FROM KOPO_PRODUCT_VOLUME A;

SELECT A.*,
    ROUND(A.VOLUME * 0.7, 0) AS CALIB_VOLUME
FROM KOPO_PRODUCT_VOLUME A;

-- CEIL 올림
-- FLOOR 버림
-- ROUND 반올림

SELECT A.*,
    CEIL(2.35343287423) AS CALIB_VOLUME
FROM KOPO_PRODUCT_VOLUME A; --3

SELECT A.*,
    FLOOR(2.35343287423) AS CALIB_VOLUME
FROM KOPO_PRODUCT_VOLUME A; --2

SELECT A.*,
    ROUND(2.35343287423) AS CALIB_VOLUME
FROM KOPO_PRODUCT_VOLUME A; --2

SELECT A.*,
    ROUND (CEIL(2.35343287423)) AS CALIB_VOLUME
FROM KOPO_PRODUCT_VOLUME A; -- 이런 것도 가능하다

SELECT *
FROM KOPO_PROMOTION;

-- KOPO_PROMOTION 테이블에서 조회를 통해
-- MAP에 10%할인된 가격을 ROUND 처리하여
-- ‘PMAP10’이라는 컬럼을 생성하세요
SELECT A.*,
    ROUND (PMAP * 0.9) AS PMAP10
FROM KOPO_PROMOTION A;

-- KOPO_PROMOTION 테이블에서
-- PMAP/MAP_PRICE 비율을 구해서 PERCENT 컬럼을 생성하세요
SELECT A.*,
    (PMAP / MAP_PRICE)*100 AS PERCENT
FROM KOPO_PROMOTION A;


-- WHERE 


-- BETWEEN A AND B
-- A와 B 사이에 있는 범위 값을 모두 검색 (A, B 값 포함)
SELECT *
FROM KOPO_PRODUCT_VOLUME
WHERE 1=1
AND YEARWEEK BETWEEN 201501 AND 201503;

-- IN, NOT IN(A, B, C) 
-- A이거나 B이거나 C인 조건

-- BLUESTAR와 BJ_WHOLESALE을 포함한 결과만!
SELECT *
FROM KOPO_CHANNEL_RESULT
WHERE 1=1
AND ACCOUNTNAME IN ('BLUESTAR', 'BJ_WHOLESALE');

-- BLUESTAR와 BJ_WHOLESALE을 제외한 결과만!
SELECT *
FROM KOPO_CHANNEL_RESULT
WHERE 1=1
AND ACCOUNTNAME NOT IN ('BLUESTAR', 'BJ_WHOLESALE');

SELECT *
FROM KOPO_CHANNEL_RESULT
WHERE 1=1
AND ACCOUNTNAME IN ('VEDIO_ONLY', 'VIDNAUD_CENTER');
-- ACCOUNTNAME이 IN 안에 있는 경우에는 다 조회하라!

SELECT *
FROM ACCOUNT_NOT_IN;

-- 조회된 결과가 컬럼 한 개인 경우에는 값으로 이해 (,로 이루어져 있다고 생각)
SELECT *
FROM KOPO_CHANNEL_RESULT
WHERE 1=1
AND ACCOUNTNAME IN ( SELECT ACCOUNTNAME
                     FROM ACCOUNT_NOT_IN );

-- 거래하지 않는 거래처 이름 (중복제거)
-- SELECT 결과를 다시 감싸면 FROM 안의 내용을 하나의 테이블로 인식한다.
SELECT DISTINCT ACCOUNTNAME
FROM (
    SELECT *
    FROM KOPO_CHANNEL_RESULT
    WHERE 1=1
    AND ACCOUNTNAME IN ( SELECT ACCOUNTNAME
                         FROM ACCOUNT_NOT_IN )
);

-- 거래하지 않는 거래처 이름 (중복제거 X)
SELECT ACCOUNTNAME 
FROM (
    SELECT *
    FROM KOPO_CHANNEL_RESULT
    WHERE 1=1
    AND ACCOUNTNAME IN ( SELECT ACCOUNTNAME
                         FROM ACCOUNT_NOT_IN )
);

-- LIKE : 특정 패턴을 가지고 있는 조건을 검색
-- B로 시작하는 모든 것을 조회
SELECT *
FROM KOPO_CHANNEL_RESULT
WHERE 1=1
AND ACCOUNTNAME LIKE 'B%';

-- LIKE '%키워드%'
-- B가 들어가는 모든 것을 조회 
SELECT *
FROM KOPO_CHANNEL_RESULT
WHERE 1=1
AND ACCOUNTNAME LIKE '%B%';

SELECT *
FROM TABS
WHERE 1=1
AND TABLE_NAME LIKE '%PARAM%';

SELECT *
FROM TABS
WHERE 1=1
AND TABLE_NAME LIKE '%FINAL%';

-- IS NULL / IS NOT NULL : NULL 값을 검색, NULL이 아닌 값을 검색!
-- 데이터 양이 많은 상황에서 비어있는 값을 확인하고 싶을 때!
-- 참고) IS NULL이 모든 것을 걸러주진 않는다
SELECT *
FROM NULL_CHECK
WHERE 1=1
AND B IS NULL;


--KOPO_PRODUCT_VOLUME 테이블에서? 연산자를 활용하여?
--‘ST0001’의 201544~201548 주차 실적만 조회하세요?
-- ST0001 이 없다! ST0002만 있는 상황
SELECT DISTINCT PRODUCTGROUP
FROM KOPO_PRODUCT_VOLUME;

-- cf) SELECT 한 결과로 테이블 생성해서 데이터를 부풀릴 수 있다.
CREATE TABLE KOPO_PRODUCT_VOLUME AS
    SELECT REGIONID,
       'ST0001' AS PRODUCTGROUP,
       YEARWEEK,
       VOLUME
    FROM KOPO_PRODUCT_VOLUME
    UNION
    SELECT *
    FROM KOPO_PRODUCT_VOLUME;

-- cf) SELECT한 결과를 INSERT해서 데이터를 부풀릴 수 있다.
INSERT INTO KOPO_PRODUCT_VOLUME
    SELECT REGIONID,
        'ST0003' AS PRODUCTGROUP,
        YEARWEEK,
        VOLUME
    FROM KOPO_PRODUCT_VOLUME;


-- FROM 절의 서브쿼리
-- 조회한 결과를 가지고 진행할 수 있다는 점!

--KOPO_PRODUCT_VOLUME 테이블에서? 연산자를 활용하여?
--‘ST0001’의 201544~201548 주차 실적만 조회하세요?
SELECT *
FROM KOPO_PRODUCT_VOLUME
WHERE 1=1 
AND PRODUCTGROUP = 'ST0001' 
AND YEARWEEK BETWEEN 201544 AND 201548;

SELECT *
FROM KOPO_PRODUCT_VOLUME
WHERE 1=1 
AND PRODUCTGROUP IN 'ST0001' 
AND YEARWEEK BETWEEN 201544 AND 201548;


-- HOLIDAY_NAME이 BF인 YEARWEEK 중에서
-- ‘ST0001’의 201544~201548 주차 실적만 조회하세요?

SELECT YEARWEEK2
FROM HOLIDAY_TABLE
WHERE 1=1
AND HOLIDAY_NAME = 'BF'; 

SELECT YEARWEEK
FROM KOPO_PRODUCT_VOLUME
WHERE 1=1
AND PRODUCTGROUP = 'ST0001'
AND YEARWEEK IN ( SELECT YEARWEEK2
                  FROM HOLIDAY_TABLE
                  WHERE 1=1
                  AND HOLIDAY_NAME = 'BF' ) ;
                  
